import operator
import os

from PyQt5.QtGui import QColor, QFont, QIcon, QKeyEvent
from PyQt5.QtMultimedia import QSound
from PyQt5.QtWidgets import QMainWindow, QMessageBox, QLabel, QTextBrowser

from hrmengine import parser

from ui.hrm_ui import Ui_MainWindow
from PyQt5.QtCore import QCoreApplication, Qt, QSize

from hrmengine import cpu
from hrmengine.cpu import ExecutionExceptin
from hrmengine.parser import parse_address
from util.UpdateLevelDate import update_level_data
from util.MyUtil import get_level_data, read_file
from util.MyEnum import State


# Form implementation generated from reading ui file 'GameWindow.py'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


class GameWindow(QMainWindow, Ui_MainWindow):
    def __init__(self, setup, level_num=1):
        super().__init__()
        self.setupUi(self)
        self.setup = setup
        # load level info
        self.load_level_info(level_num)
        self.level_num = level_num

        # Button event triggering
        self.u_start_btn.clicked['bool'].connect(self.start_event)
        self.u_next_btn.clicked['bool'].connect(self.next_event)
        self.u_pause_btn.clicked['bool'].connect(self.stop_event)
        self.u_goon_btn.clicked['bool'].connect(self.goon_evnet)
        self.u_exit_btn.clicked['bool'].connect(self.exit_event)
        self.bgmButton.clicked['bool'].connect(self.switch_bgm_state)
        self.operation_connection()
        self.check_text()

        # 设置icon
        self.bgmButton.setIcon(QIcon('resources/icons/sound/bell.png'))
        self.bgmButton.setIconSize(QSize(42, 42))
        # 1表示bgm正在播放，0表示停止
        self.bgm_state = 1
        self.play_bgm()

        # 跳关
        self.key = ''

        # 绑定信号槽
        self.pushButtonPrev.clicked.connect(self.stackedWidget.slideInPrev)
        self.pushButtonNext.clicked.connect(self.stackedWidget.slideInNext)
        # set slider bar
        self.u_speed_slider.valueChanged.connect(self.change_speed)
        self.origin_flash_time = 10000
        self.flash_time = self.origin_flash_time // self.u_speed_slider.value()
        # 无边框
        self.setWindowFlag(Qt.FramelessWindowHint)
        self.pre_process()
        self.last_item = None
        self.state = None
        self.process_state = State.INIT

        # 记录代码执行次数
        self.total_count = 0

    def switch_bgm_state(self):
        if self.bgm_state == 1:
            self.stop_bgm()
            self.bgmButton.setIcon(QIcon('resources/icons/sound/bell-dash.png'))
            self.bgm_state = 0
        else:
            self.play_bgm()
            self.bgmButton.setIcon(QIcon('resources/icons/sound/bell.png'))
            self.bgm_state = 1

    def play_bgm(self):
        if self.level_num != 10:
            self.bgm = QSound('resources/music/level1.wav')
        else:
            self.bgm = QSound('resources/music/level10.wav')
        self.bgm.setLoops(QSound.Infinite)
        self.bgm.play()

    def stop_bgm(self):
        self.bgm.stop()

    def change_speed(self):
        self.flash_time = self.origin_flash_time // self.u_speed_slider.value()

    def start_event(self):
        self.process_state = State.INIT
        self.u_code_droplist.set_forbidden_drag()
        self.process()

    def next_event(self):
        self.process_state = State.NEXT

    def stop_event(self):
        self.process_state = State.STOP

    def goon_evnet(self):
        self.process_state = State.GOON

    def exit_event(self):
        self.process_state = State.EXIT

    def track_code(self, row):
        if self.last_item is not None:
            self.last_item.setBackground(QColor("#886C54"))
        this_item = self.u_code_droplist.item(row)
        this_item.setBackground(QColor("#90FCFC"))
        self.last_item = this_item

    def untrack_code(self):
        self.last_item.setBackground(QColor("#886C54"))

    def input_flash(self, next_state):
        self.u_input_list.inbox(self.flash_time)
        self.u_pointer.set_value(next_state.pointer, self.flash_time)

    def output_flash(self, next_state):
        self.u_pointer.display_outbox(self.flash_time)
        self.u_output_list.outbox(next_state.outbox[-1], self.flash_time)

    def copyto_flash(self, state, address):
        id = parse_address(state, address)
        self.u_pointer.display_value(self.flash_time)
        self.u_register_group.display_set_value(id, state.pointer, self.flash_time)

    def copyfrom_flash(self, state, address):
        id = parse_address(state, address)
        val = self.u_register_group.display_get_value(id, self.flash_time)
        self.u_pointer.set_value(val, self.flash_time)

    def add_flash(self, state, address):
        id = parse_address(state, address)
        self.u_pointer.display_value(self.flash_time)
        val = self.u_register_group.display_get_value(id, self.flash_time)
        new_val = state.pointer + int(val)
        self.u_pointer.set_value(new_val, self.flash_time)

    def sub_flash(self, state, address):
        id = parse_address(state, address)
        self.u_pointer.display_value(self.flash_time)
        val = self.u_register_group.display_get_value(id, self.flash_time)
        new_val = state.pointer - int(val)
        self.u_pointer.set_value(new_val, self.flash_time)

    def bumpup_flash(self, state, address):
        id = parse_address(state, address)
        val = self.u_register_group.display_get_value(id, self.flash_time)
        new_val = int(val) + 1
        self.u_register_group.display_set_value(id, new_val, self.flash_time)
        self.u_pointer.set_value(new_val, self.flash_time)

    def bumpdn_flash(self, state, address):
        id = parse_address(state, address)
        val = self.u_register_group.display_get_value(id, self.flash_time)
        new_val = int(val) - 1
        self.u_register_group.display_set_value(id, new_val, self.flash_time)
        self.u_pointer.set_value(new_val, self.flash_time)

    def label_flash(self):
        pass

    def jump_flash(self):
        pass

    def pre_process(self):
        # init inbox and outbox
        self.u_input_list.init_inbox(self.inbox)
        self.u_output_list.init_outbox()
        # clear code box
        self.u_code_droplist.init_current_row()
        # init register group
        self.u_register_group.init_ui(2, 5, 60)
        if self.register_data is not None:
            for data in self.register_data:
                self.u_register_group.set_value(data[0], data[1])

    def load_level_info(self, level_num):
        _, self.register_data, _, _, _ = get_level_data(level_num)
        update_level_data(level_num, self.register_data)
        self.inbox, self.register_data, desc, self.outbox, self.words = get_level_data(level_num)
        self.u_op_droplist.set_level_num(level_num)
        self.u_op_droplist.init_op()
        self.u_desc.setText(desc)

        # 关卡引导文字初始化
        for word in self.words:
            text_content = QTextBrowser(self.stackedWidget)
            # 设置字体
            font = QFont()
            font.setFamily("Arial")
            font.setPointSize(10)
            text_content.setFont(font)
            # 文字换行
            # text_content.setWordWrap(True)
            # 文字居中
            # text_content.setAlignment(Qt.AlignCenter)
            text_content.setText(word.text)
            text_content.setStyleSheet('color: white')
            self.stackedWidget.addWidget(text_content)
        # 设置换页速度
        self.stackedWidget.setSpeed(10)
        # 设置播放方式
        self.stackedWidget.setOrientation(Qt.Vertical)

    def reset_pointer(self):
        self.u_pointer.reset()

    def check_pass(self):
        if operator.eq(self.state.outbox, self.outbox):
            if self.rejudge_pass():
                # 触发setup的levelup函数
                QMessageBox().information(self, "congratulations", "You pass this level!")
                self.setup.level_up()
            else:
                QMessageBox().information(self, "sorry", "This method only solves the current problem and will not work if the inbox data changes, please try again.")
        else:
            QMessageBox().information(self, "sorry", "please try again")

    def process(self):
        while True:
            if self.process_state == State.INIT:
                self.pre_process()
                ops = self.u_code_droplist.get_code_list()
                error_msgs = parser.compiling(ops)
                if error_msgs is not '':
                    QMessageBox().warning(self, "compiling error", error_msgs)
                    # reset drag mode
                    self.u_code_droplist.reset_drag()
                    self.reset_pointer()
                    return
                self.state = cpu.create_state(iter(self.inbox), ops, self.register_data)
                self.process_state = State.GOON
            elif self.process_state == State.GOON:
                try:
                    if self.state.pc != -1:
                        # CPU state
                        self.state = cpu.tick(self.state)
                        self.total_count += 1
                        if self.total_count > 200:
                            # 当执行次数超过200次
                            QMessageBox().information(self, "run time error", "endless loop")
                            self.total_count = 0
                            break
                        # show UI state
                        self.ui_show(self.state.prev_state, self.state)
                    else:
                        self.check_pass()
                        break
                except ExecutionExceptin as e:
                    if e.__str__() == "'INBOX has no more items'":
                        # if inbox is empty, check if pass this level
                        self.check_pass()
                    else:
                        QMessageBox().warning(self, "runtime error", e.__str__())
                    break
            elif self.process_state == State.STOP:
                QCoreApplication.processEvents()
            elif self.process_state == State.NEXT:
                try:
                    if self.state.pc != -1:
                        # CPU state
                        self.state = cpu.tick(self.state)
                        # show UI state
                        self.ui_show(self.state.prev_state, self.state)
                        self.process_state = State.STOP
                    else:
                        break
                except ExecutionExceptin as e:
                    QMessageBox().warning(self, "runtime error", e.__str__())
                    break
            elif self.process_state == State.EXIT:
                break
        self.pre_process()
        if self.last_item is not None:
            self.untrack_code()
        self.u_code_droplist.reset_drag()
        self.reset_pointer()

    def ui_show(self, state, next_state):
        if state.pc >= len(state.code) or state.pc < 0:
            return
        command = state.code[state.pc]
        op = command[0]
        param = None
        if len(command) > 1:
            param = command[1]

        self.track_code(state.pc)

        if op == 'INBOX':
            self.input_flash(next_state)
        elif op == 'OUTBOX':
            self.output_flash(next_state)
        elif op == 'COPYTO':
            self.copyto_flash(state, param)
        elif op == 'COPYFROM':
            self.copyfrom_flash(state, param)
        elif op == 'ADD':
            self.add_flash(state, param)
        elif op == 'SUB':
            self.sub_flash(state, param)
        elif op == 'BUMPUP':
            self.bumpup_flash(state, param)
        elif op == 'BUMPDN':
            self.bumpdn_flash(state, param)
        elif parser.is_label(op):
            self.label_flash()
        elif op == 'JUMP':
            self.jump_flash()
        elif op == 'JUMPN':
            self.jump_flash()
        elif op == 'JUMPZ':
            self.jump_flash()

    def keyReleaseEvent(self, a0: QKeyEvent) -> None:
        if a0.key() == Qt.Key_Space:
            self.key = ''
        else:
            self.key += a0.text()
        if self.key == 'angela':
            self.skip_this_level()

    def skip_this_level(self):
        self.setup.level_up()

    def operation_connection(self):
        self.pushButton_inbox.clicked.connect(lambda: self.help(self.pushButton_inbox.text()))
        self.pushButton_outbox.clicked.connect(lambda: self.help(self.pushButton_outbox.text()))
        self.pushButton_jump.clicked.connect(lambda: self.help(self.pushButton_jump.text()))
        self.pushButton_jumpn.clicked.connect(lambda: self.help(self.pushButton_jumpn.text()))
        self.pushButton_jumpz.clicked.connect(lambda: self.help(self.pushButton_jumpz.text()))
        self.pushButton_copyto.clicked.connect(lambda: self.help(self.pushButton_copyto.text()))
        self.pushButton_copyfrom.clicked.connect(lambda: self.help(self.pushButton_copyfrom.text()))
        self.pushButton_label.clicked.connect(lambda: self.help(self.pushButton_label.text()))
        self.pushButton_add.clicked.connect(lambda: self.help(self.pushButton_add.text()))
        self.pushButton_sub.clicked.connect(lambda: self.help(self.pushButton_sub.text()))
        self.pushButton_bumpup.clicked.connect(lambda: self.help(self.pushButton_bumpup.text()))
        self.pushButton_bumpdown.clicked.connect(lambda: self.help(self.pushButton_bumpdown.text()))

    def check_text(self):
        help = {
            'INBOX': '取出inbox中的一个方块的内容，并将值传递到bus中',
            'OUTBOX': '将bus中的内容传递到outbox中，并将bus置为None',
            'COPYFROM': '接受一个目标X，将register中的第X个格子内容复制到bus中',
            'COPYTO': '接受一个目标X，将bus中的值复制到register中的第X个格子中',
            'ADD': '接受一个目标X，将bus中的内容和register中第X个格子的值相加，并用得到的结果覆盖bus',
            'SUB': '接受一个目标X，将bus中的内容减去register中第X个格子的值，并用得到的结果覆盖bus',
            'JUMP': '接受一个目标X，跳转到设置相同目标的LABEL操作的位置上',
            'LABEL': '设置一个目标X，用于引导JUMP操作的跳转位置',
            'JUMPN': '接受一个目标X，如果bus中内容为数字且为负数，执行此操作[该操作的执行参照JUMP]，否则跳过此操作',
            'JUMPZ': '接受一个目标X，如果bus中内容为数字且为0，执行此操作[该操作的执行参照JUMP]，否则跳过此操作',
            'BUMPUP': '接受一个目标X，该操作只能对于已存在内容的register的第X个格子使用，该操作会第X个格子的内容加1，然后将结果覆盖bus内容',
            'BUMPDN': '接受一个目标X，该操作只能对于已存在内容的register的第X个格子使用，该操作会第X个格子的内容减1，然后将结果覆盖bus内容'
        }
        l = read_file('resources/level/op_' + str(self.level_num) + '.txt')

        for op in l:
            if op in help:
                self.set_op_text(op)

    def set_op_text(self, op):
        if op == 'INBOX':
            self.pushButton_inbox.setText(op)
        elif op == 'OUTBOX':
            self.pushButton_outbox.setText(op)
        elif op == 'JUMP':
            self.pushButton_jump.setText(op)
        elif op == 'JUMPN':
            self.pushButton_jumpn.setText(op)
        elif op == 'JUMPZ':
            self.pushButton_jumpz.setText(op)
        elif op == 'LABEL':
            self.pushButton_label.setText(op)
        elif op == 'COPYFROM':
            self.pushButton_copyfrom.setText(op)
        elif op == 'COPYTO':
            self.pushButton_copyto.setText(op)
        elif op == 'ADD':
            self.pushButton_add.setText(op)
        elif op == 'SUB':
            self.pushButton_sub.setText(op)
        elif op == 'BUMPUP':
            self.pushButton_bumpup.setText(op)
        elif op == 'BUMPDN':
            self.pushButton_bumpdown.setText(op)

    def help(self, op):
        help_content = {
            'INBOX': '取出inbox中的一个方块的内容，并将值传递到bus中',
            'OUTBOX': '将bus中的内容传递到outbox中，并将bus置为None',
            'COPYFROM': '接受一个目标X，将register中的第X个格子内容复制到bus中',
            'COPYTO': '接受一个目标X，将bus中的值复制到register中的第X个格子中',
            'ADD': '接受一个目标X，将bus中的内容和register中第X个格子的值相加，并用得到的结果覆盖bus',
            'SUB': '接受一个目标X，将bus中的内容减去register中第X个格子的值，并用得到的结果覆盖bus',
            'JUMP': '接受一个目标X，跳转到设置相同目标的LABEL操作的位置上',
            'LABEL': '设置一个目标X，用于引导JUMP操作的跳转位置',
            'JUMPN': '接受一个目标X，如果bus中内容为数字且为负数，执行此操作[该操作的执行参照JUMP]，否则跳过此操作',
            'JUMPZ': '接受一个目标X，如果bus中内容为数字且为0，执行此操作[该操作的执行参照JUMP]，否则跳过此操作',
            'BUMPUP': '接受一个目标X，该操作只能对于已存在内容的register的第X个格子使用，该操作会第X个格子的内容加1，然后将结果覆盖bus内容',
            'BUMPDN': '接受一个目标X，该操作只能对于已存在内容的register的第X个格子使用，该操作会第X个格子的内容减1，然后将结果覆盖bus内容'
        }
        if op != '?':
            self.code_desc_browser.setText(help_content[op])
        else:
            self.code_desc_browser.setText('???')

    def rejudge_pass(self):
        _, register_data, _, _, _ = get_level_data(self.level_num)
        update_level_data(self.level_num, register_data)
        inbox,  register_data, _, outbox, _= get_level_data(self.level_num)
        self.inbox = inbox
        ops = self.u_code_droplist.get_code_list()

        state = cpu.create_state(iter(inbox), ops, register_data)
        while state.pc != -1:
            state = cpu.tick(state)
        if operator.eq(state.outbox, outbox):
            return True
        else:
            return False
